# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Епанешников В. С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |      4-       |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

На мой взгляд, списки из Prolog очень напоминают односвязные списки из императивных языков: текущий элемент (голова) + ссылка на следующий (хвост). Основой работы со списком является рекурсивное разделение его на голову и хвост, за счёт чего мы можем по нему перемещаться. В императивных языках всё иначе. Навигация происходит либо с помощью итераторов либо при обращении по индексу. Также список в императивном языке может содержать в себе только элементы одинкового типа, в Прологе списки содержат любые элементы.

## Задание 1.1: Предикат обработки списка

`insert(T, X, 1, [X|T]), insert2(L, Val, N, Result)` - вставка элемента в список на указанную позицию 

(Список, Элемент, Позиция, Новый список)

Примеры использования:
```prolog
?- insert([], 100, 1, X).
X = [100].

?- insert([1,2,3,5,6,7], 4, 4, X).
X = [1, 2, 3, 4, 5, 6, 7].
```

Реализация:
```prolog
% Без стандартных предикатов
insert(T, X, 1, [X|T]) :- !.
insert([H|T], X, N, L) :- 
    M is N - 1, 
    insert(T, X, M, L1), 
    L = [H|L1].

% Со стандартными предикатами
insert2(L, Val, N, Result) :-
	length(X, N1),
	N1 is N - 1,
	append(X, Y, L),
	append(X, [Val], Temp),
	append(Temp, Y, Result), !.
```

проще: append(X, [Val], Temp),	append(Temp, Y, Result) =        append(X, [Val|Y], Result)

Реализация  стандартных предикатов д.б. в отчете.

`insert` - рекурсивно отделяем голову от хвоста, постоянно вычитая из N единицу до того момента, как мы окажемся на нужной позиции (N станет равным одному). Затем вставляем элемент и возвращаемся из рекурсии, возвращая список в начальное состояние.

`insert2` - вставка элемента с помощью стандартных предикатов append и length. X - список левее вставленного элемента, Y - правее элемента, TEMP - список X вместе с элементом в конце. Склеиваем списки Temp и Y и получаем искомый.

## Задание 1.2: Предикат обработки числового списка

`min_position([L|List],I), min_list(Lst, Ind)` - вычисление позиции максимального элемента в списке. (Список, Позиция).

Примеры использования:
```prolog
?- min_position([7,23,2,8,30,100], X).
X = 3.

?- min_list([10,9,8,6,1,5,4,3,2], X).
X = 5.
```

Реализация:
```prolog
% Без стандартных предикатов     
min_position([L|List],I) :-
	getMin([L|List], M),
	getIndex([L|List],M,1,I), !.

getMin([M],M).
getMin([M|T],M) :- getMin(T,Q), M < Q, !.
getMin([_|T],M) :- getMin(T,M).
	
getIndex([L|_],L,I,I).
getIndex([_|List],M,C,I):-
	Counter is C + 1,
	getIndex(List,M,Counter,I).

% Со стандартными предикатами
min_list(Lst, Ind) :-
	member(Max, Lst),
	\+((member(N, Lst), N < Max)),
	nth0(I, Lst, Max), 
	Ind is I + 1, !.
```

`min_position, min_list` - сначала вычисляем максимум в списке (getMin - вычисляет минимум), затем по значению находим позицию этого элемена. В первой реализации были написаны вспомогательные предикаты getMin и getIndex, а во второй - использовались стандартные предикаты member и nth0.



## Задание 2: Реляционное представление данных

Для себя из преимуществ реляционного представления смог выделить то, что эта модель сама по себе достаточно простая, легкая для понимания человеком. Из недостатков - могут появится трудности при разработке в достаточно простых местах. 

В моем представлении факты записывались следующим образом: student(группа, студент, [grade(предмет1, оценка), grade(предмет2, оценка)]...). Я считаю, что такое представление очень экономно, мало повторяющейся информации, так как в одном предикате записана вся информация о студенте. Это упрощает обработку данных, с помощью встроенного предиката findall легко найти любую информацию о студенте.

Вариант 2.

Первый предикат: `task1(Subj, Average)` - печатает средний балл для каждого предмета.

Примеры использования:
```prolog
?- task1(X, Y).
X = 'Логическое программирование',
Y = 4 ;
X = 'Математический анализ',
Y = 3.5 ;
X = 'Функциональное программирование',
Y = 3.5 ;
X = 'Информатика',
Y = 3.5 ;
X = 'Английский язык',
Y = 3.5 ;
X = 'Психология',
Y = 3.5.
```

Реализация:
```prolog
sum_grades([],0).
sum_grades([H|T],N) :- 
    sum_grades(T,M), 
    N is H + M.

check1(X, Subject) :-
    student(_, _, List),
    member(grade(Subject, X), List).

task1(Subj, Average) :-
    subject(Subject, Subj),
    setof(X, check1(X, Subject), NewList),
    length(NewList, N),
    sum_grades(NewList, Sum),
    Average is Sum / N.
```
Записываем в список все оценки кокретного предмета (setof), вычисляем длину списка (length), суммируем все оценки (sum_grades) и, наконец, считаем средний балл (Average is Sum / N).

Второй предикат: `task22(), task2(X, Y)` - для каждой группы находит количество не сдавших студентов.

Примеры использования:
```prolog
?- task22().
101: 4
104: 4
103: 3
102: 3
true.

?- task2(X, Y).
X = 102,
Y = 3 ;
X = 101,
Y = 4 ;
X = 104,
Y = 4 ;
X = 102,
Y = 3 ;
X = 104,
Y = 4 ;
X = 101,
Y = 4 ;
X = 103,
Y = 3 ;
% ... и так далее
```

Реализация:
```prolog
% Вывод с повторениями
check(Name, Group) :-
    student(Group, Name, List), 
    member(grade(_, 2), List).

task2(Group, Result) :-
    student(Group, _, _),
    findall(Name, check(Name, Group), List), 
    length(List, Result).

% Другая реализация второго подзадания с нормальным выводом
withoutcopy([], []):-!.
withoutcopy([X|L], List):-
          member(X, L),
	  !, 
	  withoutcopy(L, List).
withoutcopy([X|L], [X|List]):-
	  !, 
	  withoutcopy(L, List).

task22():-
	findall(Gr, student(Gr, _, _), Group),
	withoutcopy(Group, G),
	count(G).

check(Group) :-
    student(Group, _, List), 
    member(grade(_, 2), List).

count([]) :- !.
count([Group|T]) :-
    findall(Group, check(Group), List),
	length(List, Result),
	write(Group), write(': '),write(Result), nl,
	count(T).
```
Два предиката. Первый с аргументами X и Y, второй без аргументов с write. Как видно в примере использования task2(X, Y) выводит правильные ответы несколько раз (всего 24 раза - количество студентов). Данную проблему я не смог исправить, поэтому реализовал второй предикат, который не использует переменные.

`task22()` - пробегаюсь по студентам и запоминаю все группы в список, затем предикат withoutcopy удаляет все повторения и возвращает список [101, 104, 103, 102]. Далее вызываю рекурсивную функцию count, которая принимает один аргумент (список Group) и вычисляет для каждой группы количество не сдавших студентов с помощью предиката findall.

`task2(X, Y)` - записываю в список имена студентов, у которых есть оценка "2" (findall) и вычисляю длину этого списка.

Третий предикат: `task3(Subj, N)` - находит количество не сдавших студентов для каждого из предметов 

Примеры использования:
```prolog
?- task3(X, Y).
X = 'Логическое программирование',
Y = 0 ;
X = 'Математический анализ',
Y = 3 ;
X = 'Функциональное программирование',
Y = 3 ;
X = 'Информатика',
Y = 3 ;
X = 'Английский язык',
Y = 2 ;
X = 'Психология',
Y = 3.
```

Реализация:
```prolog
check3(Name, Subject) :-
    student(_, Name, List),
    member(grade(Subject, 2), List).

task3(Subj, N) :-
    subject(Subject, Subj),
    findall(Name, check3(Name, Subject), NewList),
    length(NewList, N).
```
С помощью предиката findall записываю в список имена студентов, которые имеют оценку "2" и вычисляю длину этого списка.

## Выводы

На мой взгляд, пролог отлично подходит для решения логических задач и задач, связанных с множествами, в которых много различных условий. Остальные же задания, как, к примеру, второе, связанные с парсингом текста и обработкой каких-либо данных, зачастую проще решаются при помощи императивных языков программирования. Несмотря на все его минусы, мне очень понравилось программировать на прологе. Также хочется отметить, что при выполнении лабораторной работы я отлаживал свою программу с помощью trace, что помогло мне быстрее понять, как работает пролог.

Если говорить про саму лабораторную работу, то с первым заданием проблем не возникло, описал 2 простых предиката по обработке списков, а вот во втором столкнулся с некоторыми проблемами. По последним коммитам можно увидеть, что сначала я решил задание с некоректным выводом и только через некоторое время смог найти более красивое решение.





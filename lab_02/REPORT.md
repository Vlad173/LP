#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Епанешников В.С.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     4-        |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения задач, представление которых можно описать набором некоторых состояний объектов, можно применять различные алгоритмы поиска в графах. Так, граф можно легко получить, если определить состояния, как его вершины, а дуги, как переходы из одного состояния в другое. Так как любой алгоритм поиска представляет из себя нахождение пути из одной вершины в другую, то в рамках задачи этот путь является ответом на то, какими переходами из одних состояний в другие можно достичь конечного состояния. Благодаря тому, что поиск решения на Prolog'е основан на обходе дерева, подобные задачи легко решаются использованием алгоритмов поиска. Если при поиске была достигнута вершина(состояние), из которого дальше пути нет, то необходимо откатиться до какого-то предыдущего состояния, которое определяется алгоритмом. Такой процесс backtracing'а заложен "внутри" Prolog'а, поэтому нет необходимости писать в программе дополнительный код. Именно поэтому Prolog является отличным средством для решения подобных задач. 

## Задание

Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное число шагов, если в их распоряжении имеется трехместная лодка и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве.

## Принцип решения

Для решения данной задачи и сравнения разных алгоритмов я реализовал сразу три вида поиска: поиск в глубину, в ширину и с итерационным заглублением, однако поиск в глубину не решает данную задачу, поскольку не сразу выводит решения с минимальным числом шагов.

```prolog
% Поиск в глубину
search_dfs :-
    path_dfs([[3, 3, left]], [0, 0, right], Result),
    print_res(Result).

path_dfs([X|T], X, [X|T]).
path_dfs(P, Y, R) :-
    prolong(P, P1),
    path_dfs(P1, Y, R).

% Поиск в ширину
search_bfs :-
    path_bfs([ [[3, 3, left]] ], [0, 0, right], Result),
    print_res(Result).

path_bfs([[X|T]|_], X, [X|T]).
path_bfs([P|QI], X, R) :-
    findall(Z, prolong(P, Z), T),
    append(QI, T, QQ), !,
    path_bfs(QQ, X, R).
path_bfs([_|T], X, R) :- path_bfs(T, X, R).

% Поиск с итерационным заглублением
search_id :-
    my_integer(Level),
    path_id([[3, 3, left]], [0, 0, right], Result, Level),
    print_res(Result).

path_id([X|T], X, [X|T], 0).
path_id(P, Y, R, N) :- 
    N > 0,
    prolong(P, P1),
    N1 is N - 1,
    path_id(P1, Y, R, N1).
``` 

Вспомогательные предикаты:

```prolog
my_integer(1).
my_integer(M) :- my_integer(N), M is N + 1.

prolong([X|T], [Y, X|T]) :-
    move(X, Y, _),
    condition(Y),
    not(member(Y, [X|T])).

condition([A, B, _]) :-
    (A >= B ; A = 0),
	C is 3 - A, D is 3 - B,
	(C >= D ; C = 0).

print_res([_]).
print_res([A,B|T]):-
	print_res([B|T]),
	move(B, A, Action),
	write(B),write(' -> '),
	write(A),write(': '),
	write(Action), nl.
```
Краткое описание:
1) `prolong` используется во всех алгоритмах для продления в другие состояния.
2) `my_integer`, перебор натуральных чисел, нужен для поиска с итерационным заглублением.
3) `print_res` - вывод результата работы всех поисков.
4) `condition` -  дополнительное условие для поиска - "миссионеры не должны оставаться в меньшинстве в лодке и на берегу".

Далее я перечислил предикаты, которые нужны для перехода из одного состояния в другое, а именнно, все действия, которые могут совершить миссионеры и каннибалы.

```prolog
move([A, B, left], [C, B, right], '1 миссионер переплывает на правый берег' ) :-
    A > 0, C is A - 1.
move([A, B, left], [C, B, right], '2 миссионера переплывают на правый берег' ) :-
    A > 1, C is A - 2.
move([A, B, left], [C, B, right], '3 миссионера переплывают на правый берег' ) :-
    A > 2, C is A - 3.
move([A, B, left], [A, D, right], '1 каннибал переплывает на правый берег' ) :-
    B > 0, D is B - 1.
move([A, B, left], [A, D, right], '2 каннибала переплывают на правый берег' ) :-
    B > 1, D is B - 2.
move([A, B, left], [A, D, right], '3 каннибала переплывают на правый берег' ) :-
    B > 2, D is B - 3.
move([A, B, left], [C, D, right], '1 миссионер и 1 каннибал переплывают на правый берег' ) :-
    A > 0, B > 0, C is A - 1, D is B - 1.
move([A, B, left], [C, D, right], '2 миссионера и 1 каннибал переплывают на правый берег' ) :-
    A > 1, B > 0, C is A - 2, D is B - 1.

move([A, B, right], [C, B, left], '1 миссионер переплывает на левый берег') :-
    A < 3, C is A + 1.
move([A, B, right], [C, B, left], '2 миссионера переплывают на левый берег') :-
    A < 2, C is A + 2.
move([A, B, right], [C, B, left], '3 миссионера переплывают на левый берег') :-
    A < 1, C is A + 3.
move([A, B, right], [A, D, left], '1 каннибал переплывает на левый берег') :-
    B < 3, D is B + 1.
move([A, B, right], [A, D, left], '2 каннибала переплывают на левый берег') :-
    B < 2, D is B + 2.
move([A, B, right], [A, D, left], '3 каннибала переплывают на левый берег') :-
    B < 1, D is B + 3.
move([A, B, right], [C, D, left], '1 миссионер и 1 каннибал переплывают на левый берег') :-
    A < 3, B < 3, C is A + 1, D is B + 1.
move([A, B, right], [C, D, left], '2 миссионера и 1 каннибал переплывают на левый берег') :-
    A < 2, B < 3, C is A + 2, D is B + 1.
```

## Результаты

1. Поиск в глубину.
```prolog
?- search_dfs.
[3,3,left] -> [3,1,right]: 2 каннибала переплывают на правый берег
[3,1,right] -> [3,2,left]: 1 каннибал переплывает на левый берег
[3,2,left] -> [0,2,right]: 3 миссионера переплывают на правый берег
[0,2,right] -> [2,2,left]: 2 миссионера переплывают на левый берег
[2,2,left] -> [1,1,right]: 1 миссионер и 1 каннибал переплывают на правый берег
[1,1,right] -> [3,1,left]: 2 миссионера переплывают на левый берег
[3,1,left] -> [0,1,right]: 3 миссионера переплывают на правый берег
[0,1,right] -> [1,1,left]: 1 миссионер переплывает на левый берег
[1,1,left] -> [0,0,right]: 1 миссионер и 1 каннибал переплывают на правый берег
true .
```

2. Поиск в ширину.
```prolog
?- search_bfs.
[3,3,left] -> [3,1,right]: 2 каннибала переплывают на правый берег
[3,1,right] -> [3,2,left]: 1 каннибал переплывает на левый берег
[3,2,left] -> [0,2,right]: 3 миссионера переплывают на правый берег
[0,2,right] -> [0,3,left]: 1 каннибал переплывает на левый берег
[0,3,left] -> [0,0,right]: 3 каннибала переплывают на правый берег
true .
```

3. Поиск с итеративным погружением.
```prolog
?- search_id.
[3,3,left] -> [3,1,right]: 2 каннибала переплывают на правый берег
[3,1,right] -> [3,2,left]: 1 каннибал переплывает на левый берег
[3,2,left] -> [0,2,right]: 3 миссионера переплывают на правый берег
[0,2,right] -> [0,3,left]: 1 каннибал переплывает на левый берег
[0,3,left] -> [0,0,right]: 3 каннибала переплывают на правый берег
true .
```

| Алгоритм поиска |  Длина найденного первым пути  |  Время работы  |
|-----------------|--------------------------------|----------------|
| В глубину       |               11               |     30 ms.     |
| В ширину        |                5             |         30 ms.       |
| ID              |               11                 |       30 ms.   |


## Выводы

Лабораторная работа показывает ещё одно из применений различных видов поиска в графах: нахождение решений в пространстве состояний для решения логических задачах.

Поиск в глубину используется, когда необходимо найти хотя бы какое-либо решение, в то время как поиск в ширину подразумевает необходимость найти решение как можно быстрее, кратчайший путь. Поиск в ширину в некоторых случаях требует значительных затрат памяти, что может негативно сказаться на работоспособности программы.

Поиск в глубину с итеративным погружением используется в тех же случаях, что и обычный поиск в глубину с одним лишь отличием: необходимостью прекратить поиск, если глубина погружения превысила определенное максимальное значение. Данный вид поиска также рационально использовать, если заранее известно, что в дереве точно содержится необходимое для нас решение на какой-либо определенной высоте.




